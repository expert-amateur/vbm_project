[35m[1mConsolidate compiler generated dependencies of target pcl_sampling[0m
[ 50%] [32mBuilding CXX object CMakeFiles/pcl_sampling.dir/src/pcl_sampling.cpp.o[0m
In file included from [01m[K/usr/include/pcl-1.12/pcl/type_traits.h:40[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/memory.h:46[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/PCLHeader.h:3[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/ModelCoefficients.h:7[m[K,
                 from [01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:1[m[K:
/usr/include/pcl-1.12/pcl/point_struct_traits.h: In instantiation of â€˜[01m[Kstruct pcl::traits::fieldList<Eigen::Matrix<float, 4, 1> >[m[Kâ€™:
[01m[K/usr/include/pcl-1.12/pcl/impl/point_types.hpp:2348:10:[m[K   required from â€˜[01m[Kstruct pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required by substitution of â€˜[01m[Ktemplate<class U> static char (& boost::mpl::aux::has_type<pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true> >::gcc_3_2_wknd::test<U>(const volatile boost::mpl::aux::type_wrapper<T>*, boost::mpl::aux::type_wrapper<typename U::type>*))[2] [with U = pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>][m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kconst bool boost::mpl::aux::has_type<pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true> >::value[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kstruct boost::mpl::aux::has_type<pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp:49:49:[m[K   required from â€˜[01m[Kstruct boost::mpl::quote2<pcl::traits::has_field, mpl_::void_>::apply<Eigen::Matrix<float, 4, 1>, pcl::fields::x>[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp:46:8:[m[K   [ skipping 35 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:47:46:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each_dispatch(Sequence&, F&, Tag) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; Tag = boost::fusion::forward_traversal_tag][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:143:34:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each(Sequence&, F&, mpl_::false_) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; mpl_::false_ = mpl_::bool_<false>][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/for_each.hpp:35:25:[m[K   required from â€˜[01m[Kconstexpr typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type boost::fusion::for_each(Sequence&, F) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type = void][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:888:29:[m[K   required from â€˜[01m[Kvoid pcl::CentroidPoint<PointT>::get(PointOutT&) const [with PointOutT = Eigen::Matrix<float, 4, 1>; PointT = pcl::PointXYZ][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:907:10:[m[K   required from â€˜[01m[Kstd::size_t pcl::computeCentroid(const pcl::PointCloud<PointT>&, PointOutT&) [with PointInT = pcl::PointXYZ; PointOutT = Eigen::Matrix<float, 4, 1>; std::size_t = long unsigned int][m[Kâ€™
[01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:133:23:[m[K   required from here
[01m[K/usr/include/pcl-1.12/pcl/point_struct_traits.h:195:8:[m[K [01;31m[Kerror: [m[Kinvalid use of incomplete type â€˜[01m[Kstruct pcl::traits::fieldList<Eigen::Matrix<float, 4, 1> >[m[Kâ€™
  195 | struct [01;31m[KfieldList[m[K /** \cond NO_WARN_RECURSIVE */ : fieldList<typename POD<PointT>::type> /** \endcond */
      |        [01;31m[K^~~~~~~~~[m[K
[01m[K/usr/include/pcl-1.12/pcl/point_struct_traits.h:195:8:[m[K [01;36m[Knote: [m[Kdeclaration of â€˜[01m[Kstruct pcl::traits::fieldList<Eigen::Matrix<float, 4, 1> >[m[Kâ€™
In file included from [01m[K/usr/include/pcl-1.12/pcl/point_struct_traits.h:40[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/type_traits.h:40[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/memory.h:46[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/PCLHeader.h:3[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/ModelCoefficients.h:7[m[K,
                 from [01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:1[m[K:
[01m[K/usr/include/pcl-1.12/pcl/point_struct_traits.h:201:3:[m[K [01;31m[Kerror: [m[Kcould not convert â€˜[01m[Kpcl::traits::fieldList<Eigen::Matrix<float, 4, 1> >::POINT_TYPE_NOT_PROPERLY_REGISTERED201::assert_arg()[m[Kâ€™ from â€˜[01m[Kmpl_::failed************ (pcl::traits::fieldList<Eigen::Matrix<float, 4, 1> >::POINT_TYPE_NOT_PROPERLY_REGISTERED::************)(Eigen::Matrix<float, 4, 1>&)[m[Kâ€™ to â€˜[01m[Kmpl_::assert<false>::type[m[Kâ€™ {aka â€˜[01m[Kmpl_::assert<false>[m[Kâ€™}
  201 |   [01;31m[KB[m[KOOST_MPL_ASSERT_MSG((!std::is_same<PointT, typename POD<PointT>::type>::value),
      |   [01;31m[K^[m[K
      |   [01;31m[K|[m[K
      |   [01;31m[Kmpl_::failed************ (pcl::traits::fieldList<Eigen::Matrix<float, 4, 1> >::POINT_TYPE_NOT_PROPERLY_REGISTERED::************)(Eigen::Matrix<float, 4, 1>&)[m[K
In file included from [01m[K/usr/include/pcl-1.12/pcl/point_types.h:354[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/common/impl/copy_point.hpp:40[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/common/copy_point.h:58[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/common/impl/io.hpp:45[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/common/io.h:538[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/io/impl/pcd_io.hpp:48[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/io/pcd_io.h:789[m[K,
                 from [01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:2[m[K:
/usr/include/pcl-1.12/pcl/impl/point_types.hpp: In instantiation of â€˜[01m[Kstruct pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>[m[Kâ€™:
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required by substitution of â€˜[01m[Ktemplate<class U> static char (& boost::mpl::aux::has_type<pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true> >::gcc_3_2_wknd::test<U>(const volatile boost::mpl::aux::type_wrapper<T>*, boost::mpl::aux::type_wrapper<typename U::type>*))[2] [with U = pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>][m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kconst bool boost::mpl::aux::has_type<pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true> >::value[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kstruct boost::mpl::aux::has_type<pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp:49:49:[m[K   required from â€˜[01m[Kstruct boost::mpl::quote2<pcl::traits::has_field, mpl_::void_>::apply<Eigen::Matrix<float, 4, 1>, pcl::fields::x>[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp:46:8:[m[K   required from â€˜[01m[Kstruct boost::mpl::apply_wrap2<boost::mpl::quote2<pcl::traits::has_field, mpl_::void_>, Eigen::Matrix<float, 4, 1>, pcl::fields::x>[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp:207:21:[m[K   [ skipping 34 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:47:46:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each_dispatch(Sequence&, F&, Tag) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; Tag = boost::fusion::forward_traversal_tag][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:143:34:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each(Sequence&, F&, mpl_::false_) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; mpl_::false_ = mpl_::bool_<false>][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/for_each.hpp:35:25:[m[K   required from â€˜[01m[Kconstexpr typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type boost::fusion::for_each(Sequence&, F) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type = void][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:888:29:[m[K   required from â€˜[01m[Kvoid pcl::CentroidPoint<PointT>::get(PointOutT&) const [with PointOutT = Eigen::Matrix<float, 4, 1>; PointT = pcl::PointXYZ][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:907:10:[m[K   required from â€˜[01m[Kstd::size_t pcl::computeCentroid(const pcl::PointCloud<PointT>&, PointOutT&) [with PointInT = pcl::PointXYZ; PointOutT = Eigen::Matrix<float, 4, 1>; std::size_t = long unsigned int][m[Kâ€™
[01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:133:23:[m[K   required from here
[01m[K/usr/include/pcl-1.12/pcl/impl/point_types.hpp:2348:10:[m[K [01;31m[Kerror: [m[Kno type named â€˜[01m[Ktype[m[Kâ€™ in â€˜[01m[Kstruct pcl::traits::fieldList<Eigen::Matrix<float, 4, 1> >[m[Kâ€™
 2348 |   struct [01;31m[Khas_field[m[K : boost::mpl::contains<typename pcl::traits::fieldList<PointT>::type, Field>::type
      |          [01;31m[K^~~~~~~~~[m[K
In file included from [01m[K/usr/include/boost/mpl/not.hpp:19[m[K,
                 from [01m[K/usr/include/boost/mpl/assert.hpp:17[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/point_struct_traits.h:40[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/type_traits.h:40[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/memory.h:46[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/PCLHeader.h:3[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/ModelCoefficients.h:7[m[K,
                 from [01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:1[m[K:
/usr/include/boost/mpl/aux_/nested_type_wknd.hpp: In instantiation of â€˜[01m[Kstruct boost::mpl::aux::nested_type_wknd<pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x> >[m[Kâ€™:
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp:23:8:[m[K   required from â€˜[01m[Kstruct boost::mpl::aux::and_impl<true, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp:48:8:[m[K   required from â€˜[01m[Kstruct boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required by substitution of â€˜[01m[Ktemplate<class U> static char (& boost::mpl::aux::has_type<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >::gcc_3_2_wknd::test<U>(const volatile boost::mpl::aux::type_wrapper<T>*, boost::mpl::aux::type_wrapper<typename U::type>*))[2] [with U = boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >][m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kconst bool boost::mpl::aux::has_type<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >::value[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kstruct boost::mpl::aux::has_type<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp:111:12:[m[K   [ skipping 33 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:47:46:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each_dispatch(Sequence&, F&, Tag) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; Tag = boost::fusion::forward_traversal_tag][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:143:34:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each(Sequence&, F&, mpl_::false_) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; mpl_::false_ = mpl_::bool_<false>][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/for_each.hpp:35:25:[m[K   required from â€˜[01m[Kconstexpr typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type boost::fusion::for_each(Sequence&, F) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type = void][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:888:29:[m[K   required from â€˜[01m[Kvoid pcl::CentroidPoint<PointT>::get(PointOutT&) const [with PointOutT = Eigen::Matrix<float, 4, 1>; PointT = pcl::PointXYZ][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:907:10:[m[K   required from â€˜[01m[Kstd::size_t pcl::computeCentroid(const pcl::PointCloud<PointT>&, PointOutT&) [with PointInT = pcl::PointXYZ; PointOutT = Eigen::Matrix<float, 4, 1>; std::size_t = long unsigned int][m[Kâ€™
[01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:133:23:[m[K   required from here
[01m[K/usr/include/boost/mpl/aux_/nested_type_wknd.hpp:26:31:[m[K [01;31m[Kerror: [m[Kno type named â€˜[01m[Ktype[m[Kâ€™ in â€˜[01m[Kstruct pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>[m[Kâ€™
   26 | template< typename T > struct [01;31m[Knested_type_wknd[m[K
      |                               [01;31m[K^~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/include/boost/mpl/aux_/include_preprocessed.hpp:37[m[K,
                 from [01m[K/usr/include/boost/mpl/and.hpp:42[m[K,
                 from [01m[K/usr/include/boost/mpl/is_sequence.hpp:18[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/for_each_type.h:46[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/conversions.h:51[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/io/file_io.h:40[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/io/pcd_io.h:45[m[K,
                 from [01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:2[m[K:
/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp: In instantiation of â€˜[01m[Kstruct boost::mpl::aux::and_impl<true, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™:
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp:48:8:[m[K   required from â€˜[01m[Kstruct boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required by substitution of â€˜[01m[Ktemplate<class U> static char (& boost::mpl::aux::has_type<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >::gcc_3_2_wknd::test<U>(const volatile boost::mpl::aux::type_wrapper<T>*, boost::mpl::aux::type_wrapper<typename U::type>*))[2] [with U = boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >][m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kconst bool boost::mpl::aux::has_type<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >::value[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kstruct boost::mpl::aux::has_type<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp:111:12:[m[K   required from â€˜[01m[Kstruct boost::mpl::quote5<boost::mpl::and_, mpl_::void_>::apply<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp:77:8:[m[K   [ skipping 32 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:47:46:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each_dispatch(Sequence&, F&, Tag) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; Tag = boost::fusion::forward_traversal_tag][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:143:34:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each(Sequence&, F&, mpl_::false_) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; mpl_::false_ = mpl_::bool_<false>][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/for_each.hpp:35:25:[m[K   required from â€˜[01m[Kconstexpr typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type boost::fusion::for_each(Sequence&, F) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type = void][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:888:29:[m[K   required from â€˜[01m[Kvoid pcl::CentroidPoint<PointT>::get(PointOutT&) const [with PointOutT = Eigen::Matrix<float, 4, 1>; PointT = pcl::PointXYZ][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:907:10:[m[K   required from â€˜[01m[Kstd::size_t pcl::computeCentroid(const pcl::PointCloud<PointT>&, PointOutT&) [with PointInT = pcl::PointXYZ; PointOutT = Eigen::Matrix<float, 4, 1>; std::size_t = long unsigned int][m[Kâ€™
[01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:133:23:[m[K   required from here
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp:23:8:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kvalue[m[Kâ€™ is not a member of â€˜[01m[Kboost::mpl::aux::nested_type_wknd<pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x> >[m[Kâ€™
   23 | struct [01;31m[Kand_impl< true,T1,T2,T3,T4 >[m[K
      |        [01;31m[K^~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/include/pcl-1.12/pcl/point_types.h:354[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/common/impl/copy_point.hpp:40[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/common/copy_point.h:58[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/common/impl/io.hpp:45[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/common/io.h:538[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/io/impl/pcd_io.hpp:48[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/io/pcd_io.h:789[m[K,
                 from [01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:2[m[K:
/usr/include/pcl-1.12/pcl/impl/point_types.hpp: In instantiation of â€˜[01m[Kstruct pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>[m[Kâ€™:
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required by substitution of â€˜[01m[Ktemplate<class U> static char (& boost::mpl::aux::has_type<pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true> >::gcc_3_2_wknd::test<U>(const volatile boost::mpl::aux::type_wrapper<T>*, boost::mpl::aux::type_wrapper<typename U::type>*))[2] [with U = pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>][m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kconst bool boost::mpl::aux::has_type<pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true> >::value[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kstruct boost::mpl::aux::has_type<pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp:49:49:[m[K   required from â€˜[01m[Kstruct boost::mpl::quote2<pcl::traits::has_field, mpl_::void_>::apply<Eigen::Matrix<float, 4, 1>, pcl::fields::y>[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp:46:8:[m[K   required from â€˜[01m[Kstruct boost::mpl::apply_wrap2<boost::mpl::quote2<pcl::traits::has_field, mpl_::void_>, Eigen::Matrix<float, 4, 1>, pcl::fields::y>[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp:207:21:[m[K   [ skipping 34 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:47:46:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each_dispatch(Sequence&, F&, Tag) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; Tag = boost::fusion::forward_traversal_tag][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:143:34:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each(Sequence&, F&, mpl_::false_) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; mpl_::false_ = mpl_::bool_<false>][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/for_each.hpp:35:25:[m[K   required from â€˜[01m[Kconstexpr typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type boost::fusion::for_each(Sequence&, F) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type = void][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:888:29:[m[K   required from â€˜[01m[Kvoid pcl::CentroidPoint<PointT>::get(PointOutT&) const [with PointOutT = Eigen::Matrix<float, 4, 1>; PointT = pcl::PointXYZ][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:907:10:[m[K   required from â€˜[01m[Kstd::size_t pcl::computeCentroid(const pcl::PointCloud<PointT>&, PointOutT&) [with PointInT = pcl::PointXYZ; PointOutT = Eigen::Matrix<float, 4, 1>; std::size_t = long unsigned int][m[Kâ€™
[01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:133:23:[m[K   required from here
[01m[K/usr/include/pcl-1.12/pcl/impl/point_types.hpp:2348:10:[m[K [01;31m[Kerror: [m[Kno type named â€˜[01m[Ktype[m[Kâ€™ in â€˜[01m[Kstruct pcl::traits::fieldList<Eigen::Matrix<float, 4, 1> >[m[Kâ€™
 2348 |   struct [01;31m[Khas_field[m[K : boost::mpl::contains<typename pcl::traits::fieldList<PointT>::type, Field>::type
      |          [01;31m[K^~~~~~~~~[m[K
In file included from [01m[K/usr/include/boost/mpl/not.hpp:19[m[K,
                 from [01m[K/usr/include/boost/mpl/assert.hpp:17[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/point_struct_traits.h:40[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/type_traits.h:40[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/memory.h:46[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/PCLHeader.h:3[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/ModelCoefficients.h:7[m[K,
                 from [01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:1[m[K:
/usr/include/boost/mpl/aux_/nested_type_wknd.hpp: In instantiation of â€˜[01m[Kstruct boost::mpl::aux::nested_type_wknd<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> > >[m[Kâ€™:
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp:48:8:[m[K   required from â€˜[01m[Kstruct boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required by substitution of â€˜[01m[Ktemplate<class U> static char (& boost::mpl::aux::has_type<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >::gcc_3_2_wknd::test<U>(const volatile boost::mpl::aux::type_wrapper<T>*, boost::mpl::aux::type_wrapper<typename U::type>*))[2] [with U = boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >][m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kconst bool boost::mpl::aux::has_type<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >::value[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kstruct boost::mpl::aux::has_type<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp:111:12:[m[K   required from â€˜[01m[Kstruct boost::mpl::quote5<boost::mpl::and_, mpl_::void_>::apply<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp:77:8:[m[K   [ skipping 32 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:47:46:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each_dispatch(Sequence&, F&, Tag) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; Tag = boost::fusion::forward_traversal_tag][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:143:34:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each(Sequence&, F&, mpl_::false_) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; mpl_::false_ = mpl_::bool_<false>][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/for_each.hpp:35:25:[m[K   required from â€˜[01m[Kconstexpr typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type boost::fusion::for_each(Sequence&, F) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type = void][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:888:29:[m[K   required from â€˜[01m[Kvoid pcl::CentroidPoint<PointT>::get(PointOutT&) const [with PointOutT = Eigen::Matrix<float, 4, 1>; PointT = pcl::PointXYZ][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:907:10:[m[K   required from â€˜[01m[Kstd::size_t pcl::computeCentroid(const pcl::PointCloud<PointT>&, PointOutT&) [with PointInT = pcl::PointXYZ; PointOutT = Eigen::Matrix<float, 4, 1>; std::size_t = long unsigned int][m[Kâ€™
[01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:133:23:[m[K   required from here
[01m[K/usr/include/boost/mpl/aux_/nested_type_wknd.hpp:26:31:[m[K [01;31m[Kerror: [m[Kno type named â€˜[01m[Ktype[m[Kâ€™ in â€˜[01m[Kstruct boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™
   26 | template< typename T > struct [01;31m[Knested_type_wknd[m[K
      |                               [01;31m[K^~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/include/boost/mpl/aux_/include_preprocessed.hpp:37[m[K,
                 from [01m[K/usr/include/boost/mpl/and.hpp:42[m[K,
                 from [01m[K/usr/include/boost/mpl/is_sequence.hpp:18[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/for_each_type.h:46[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/conversions.h:51[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/io/file_io.h:40[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/io/pcd_io.h:45[m[K,
                 from [01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:2[m[K:
/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp: In instantiation of â€˜[01m[Kstruct boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™:
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required by substitution of â€˜[01m[Ktemplate<class U> static char (& boost::mpl::aux::has_type<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >::gcc_3_2_wknd::test<U>(const volatile boost::mpl::aux::type_wrapper<T>*, boost::mpl::aux::type_wrapper<typename U::type>*))[2] [with U = boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >][m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kconst bool boost::mpl::aux::has_type<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >::value[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kstruct boost::mpl::aux::has_type<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp:111:12:[m[K   required from â€˜[01m[Kstruct boost::mpl::quote5<boost::mpl::and_, mpl_::void_>::apply<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp:77:8:[m[K   required from â€˜[01m[Kstruct boost::mpl::apply_wrap5<boost::mpl::quote5<boost::mpl::and_, mpl_::void_>, boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp:429:21:[m[K   [ skipping 31 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:47:46:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each_dispatch(Sequence&, F&, Tag) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; Tag = boost::fusion::forward_traversal_tag][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:143:34:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each(Sequence&, F&, mpl_::false_) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; mpl_::false_ = mpl_::bool_<false>][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/for_each.hpp:35:25:[m[K   required from â€˜[01m[Kconstexpr typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type boost::fusion::for_each(Sequence&, F) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type = void][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:888:29:[m[K   required from â€˜[01m[Kvoid pcl::CentroidPoint<PointT>::get(PointOutT&) const [with PointOutT = Eigen::Matrix<float, 4, 1>; PointT = pcl::PointXYZ][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:907:10:[m[K   required from â€˜[01m[Kstd::size_t pcl::computeCentroid(const pcl::PointCloud<PointT>&, PointOutT&) [with PointInT = pcl::PointXYZ; PointOutT = Eigen::Matrix<float, 4, 1>; std::size_t = long unsigned int][m[Kâ€™
[01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:133:23:[m[K   required from here
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp:48:8:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kvalue[m[Kâ€™ is not a member of â€˜[01m[Kboost::mpl::aux::nested_type_wknd<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> > >[m[Kâ€™
   48 | struct [01;31m[Kand_[m[K
      |        [01;31m[K^~~~[m[K
In file included from [01m[K/usr/include/pcl-1.12/pcl/point_types.h:354[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/common/impl/copy_point.hpp:40[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/common/copy_point.h:58[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/common/impl/io.hpp:45[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/common/io.h:538[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/io/impl/pcd_io.hpp:48[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/io/pcd_io.h:789[m[K,
                 from [01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:2[m[K:
/usr/include/pcl-1.12/pcl/impl/point_types.hpp: In instantiation of â€˜[01m[Kstruct pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>[m[Kâ€™:
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required by substitution of â€˜[01m[Ktemplate<class U> static char (& boost::mpl::aux::has_type<pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>, mpl_::bool_<true> >::gcc_3_2_wknd::test<U>(const volatile boost::mpl::aux::type_wrapper<T>*, boost::mpl::aux::type_wrapper<typename U::type>*))[2] [with U = pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>][m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kconst bool boost::mpl::aux::has_type<pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>, mpl_::bool_<true> >::value[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kstruct boost::mpl::aux::has_type<pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp:49:49:[m[K   required from â€˜[01m[Kstruct boost::mpl::quote2<pcl::traits::has_field, mpl_::void_>::apply<Eigen::Matrix<float, 4, 1>, pcl::fields::z>[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp:46:8:[m[K   required from â€˜[01m[Kstruct boost::mpl::apply_wrap2<boost::mpl::quote2<pcl::traits::has_field, mpl_::void_>, Eigen::Matrix<float, 4, 1>, pcl::fields::z>[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp:207:21:[m[K   [ skipping 34 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:47:46:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each_dispatch(Sequence&, F&, Tag) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; Tag = boost::fusion::forward_traversal_tag][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:143:34:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each(Sequence&, F&, mpl_::false_) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; mpl_::false_ = mpl_::bool_<false>][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/for_each.hpp:35:25:[m[K   required from â€˜[01m[Kconstexpr typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type boost::fusion::for_each(Sequence&, F) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type = void][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:888:29:[m[K   required from â€˜[01m[Kvoid pcl::CentroidPoint<PointT>::get(PointOutT&) const [with PointOutT = Eigen::Matrix<float, 4, 1>; PointT = pcl::PointXYZ][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:907:10:[m[K   required from â€˜[01m[Kstd::size_t pcl::computeCentroid(const pcl::PointCloud<PointT>&, PointOutT&) [with PointInT = pcl::PointXYZ; PointOutT = Eigen::Matrix<float, 4, 1>; std::size_t = long unsigned int][m[Kâ€™
[01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:133:23:[m[K   required from here
[01m[K/usr/include/pcl-1.12/pcl/impl/point_types.hpp:2348:10:[m[K [01;31m[Kerror: [m[Kno type named â€˜[01m[Ktype[m[Kâ€™ in â€˜[01m[Kstruct pcl::traits::fieldList<Eigen::Matrix<float, 4, 1> >[m[Kâ€™
 2348 |   struct [01;31m[Khas_field[m[K : boost::mpl::contains<typename pcl::traits::fieldList<PointT>::type, Field>::type
      |          [01;31m[K^~~~~~~~~[m[K
In file included from [01m[K/usr/include/boost/mpl/not.hpp:19[m[K,
                 from [01m[K/usr/include/boost/mpl/assert.hpp:17[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/point_struct_traits.h:40[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/type_traits.h:40[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/memory.h:46[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/PCLHeader.h:3[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/ModelCoefficients.h:7[m[K,
                 from [01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:1[m[K:
/usr/include/boost/mpl/aux_/nested_type_wknd.hpp: In instantiation of â€˜[01m[Kstruct boost::mpl::aux::nested_type_wknd<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> > >[m[Kâ€™:
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp:48:8:[m[K   required from â€˜[01m[Kstruct boost::mpl::and_<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required by substitution of â€˜[01m[Ktemplate<class U> static char (& boost::mpl::aux::has_type<boost::mpl::and_<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >::gcc_3_2_wknd::test<U>(const volatile boost::mpl::aux::type_wrapper<T>*, boost::mpl::aux::type_wrapper<typename U::type>*))[2] [with U = boost::mpl::and_<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >][m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kconst bool boost::mpl::aux::has_type<boost::mpl::and_<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >::value[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kstruct boost::mpl::aux::has_type<boost::mpl::and_<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp:111:12:[m[K   required from â€˜[01m[Kstruct boost::mpl::quote5<boost::mpl::and_, mpl_::void_>::apply<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp:77:8:[m[K   [ skipping 32 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:47:46:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each_dispatch(Sequence&, F&, Tag) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; Tag = boost::fusion::forward_traversal_tag][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:143:34:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each(Sequence&, F&, mpl_::false_) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; mpl_::false_ = mpl_::bool_<false>][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/for_each.hpp:35:25:[m[K   required from â€˜[01m[Kconstexpr typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type boost::fusion::for_each(Sequence&, F) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type = void][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:888:29:[m[K   required from â€˜[01m[Kvoid pcl::CentroidPoint<PointT>::get(PointOutT&) const [with PointOutT = Eigen::Matrix<float, 4, 1>; PointT = pcl::PointXYZ][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:907:10:[m[K   required from â€˜[01m[Kstd::size_t pcl::computeCentroid(const pcl::PointCloud<PointT>&, PointOutT&) [with PointInT = pcl::PointXYZ; PointOutT = Eigen::Matrix<float, 4, 1>; std::size_t = long unsigned int][m[Kâ€™
[01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:133:23:[m[K   required from here
[01m[K/usr/include/boost/mpl/aux_/nested_type_wknd.hpp:26:31:[m[K [01;31m[Kerror: [m[Kno type named â€˜[01m[Ktype[m[Kâ€™ in â€˜[01m[Kstruct boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™
   26 | template< typename T > struct [01;31m[Knested_type_wknd[m[K
      |                               [01;31m[K^~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/include/boost/mpl/aux_/include_preprocessed.hpp:37[m[K,
                 from [01m[K/usr/include/boost/mpl/and.hpp:42[m[K,
                 from [01m[K/usr/include/boost/mpl/is_sequence.hpp:18[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/for_each_type.h:46[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/conversions.h:51[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/io/file_io.h:40[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/io/pcd_io.h:45[m[K,
                 from [01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:2[m[K:
/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp: In instantiation of â€˜[01m[Kstruct boost::mpl::and_<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™:
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required by substitution of â€˜[01m[Ktemplate<class U> static char (& boost::mpl::aux::has_type<boost::mpl::and_<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >::gcc_3_2_wknd::test<U>(const volatile boost::mpl::aux::type_wrapper<T>*, boost::mpl::aux::type_wrapper<typename U::type>*))[2] [with U = boost::mpl::and_<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >][m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kconst bool boost::mpl::aux::has_type<boost::mpl::and_<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >::value[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/has_type.hpp:20:1:[m[K   required from â€˜[01m[Kstruct boost::mpl::aux::has_type<boost::mpl::and_<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp:111:12:[m[K   required from â€˜[01m[Kstruct boost::mpl::quote5<boost::mpl::and_, mpl_::void_>::apply<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp:77:8:[m[K   required from â€˜[01m[Kstruct boost::mpl::apply_wrap5<boost::mpl::quote5<boost::mpl::and_, mpl_::void_>, boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::z>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp:429:21:[m[K   [ skipping 31 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:47:46:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each_dispatch(Sequence&, F&, Tag) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; Tag = boost::fusion::forward_traversal_tag][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:143:34:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each(Sequence&, F&, mpl_::false_) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; mpl_::false_ = mpl_::bool_<false>][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/for_each.hpp:35:25:[m[K   required from â€˜[01m[Kconstexpr typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type boost::fusion::for_each(Sequence&, F) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type = void][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:888:29:[m[K   required from â€˜[01m[Kvoid pcl::CentroidPoint<PointT>::get(PointOutT&) const [with PointOutT = Eigen::Matrix<float, 4, 1>; PointT = pcl::PointXYZ][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:907:10:[m[K   required from â€˜[01m[Kstd::size_t pcl::computeCentroid(const pcl::PointCloud<PointT>&, PointOutT&) [with PointInT = pcl::PointXYZ; PointOutT = Eigen::Matrix<float, 4, 1>; std::size_t = long unsigned int][m[Kâ€™
[01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:133:23:[m[K   required from here
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp:48:8:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kvalue[m[Kâ€™ is not a member of â€˜[01m[Kboost::mpl::aux::nested_type_wknd<boost::mpl::and_<boost::mpl::and_<mpl_::bool_<true>, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::x>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, pcl::traits::has_field<Eigen::Matrix<float, 4, 1>, pcl::fields::y>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> > >[m[Kâ€™
   48 | struct [01;31m[Kand_[m[K
      |        [01;31m[K^~~~[m[K
/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp: In instantiation of â€˜[01m[Kstruct boost::mpl::aux::and_impl<true, boost::mpl::apply<pcl::traits::has_xyz<mpl_::arg<1> >, Eigen::Matrix<float, 4, 1>, mpl_::na, mpl_::na, mpl_::na, mpl_::na>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™:
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp:48:8:[m[K   required from â€˜[01m[Kstruct boost::mpl::and_<boost::mpl::apply<pcl::traits::has_xyz<mpl_::arg<1> >, pcl::PointXYZ, mpl_::na, mpl_::na, mpl_::na, mpl_::na>, boost::mpl::apply<pcl::traits::has_xyz<mpl_::arg<1> >, Eigen::Matrix<float, 4, 1>, mpl_::na, mpl_::na, mpl_::na, mpl_::na>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >[m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/accumulators.hpp:221:14:[m[K   required from â€˜[01m[Kstruct pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> >::apply<pcl::detail::AccumulatorXYZ>[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp:36:8:[m[K   required from â€˜[01m[Kstruct boost::mpl::apply_wrap1<pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> >, pcl::detail::AccumulatorXYZ>[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp:144:21:[m[K   required from â€˜[01m[Kstruct boost::mpl::bind1<pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> >, boost::mpl::bind1<boost::mpl::quote1<boost::fusion::result_of::value_of>, mpl_::arg<1> > >::apply<boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp:36:8:[m[K   required from â€˜[01m[Kstruct boost::mpl::apply_wrap1<boost::mpl::bind1<pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> >, boost::mpl::bind1<boost::mpl::quote1<boost::fusion::result_of::value_of>, mpl_::arg<1> > >, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/apply.hpp:42:8:[m[K   [ skipping 8 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:47:46:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each_dispatch(Sequence&, F&, Tag) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; Tag = boost::fusion::forward_traversal_tag][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:143:34:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each(Sequence&, F&, mpl_::false_) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; mpl_::false_ = mpl_::bool_<false>][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/for_each.hpp:35:25:[m[K   required from â€˜[01m[Kconstexpr typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type boost::fusion::for_each(Sequence&, F) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type = void][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:888:29:[m[K   required from â€˜[01m[Kvoid pcl::CentroidPoint<PointT>::get(PointOutT&) const [with PointOutT = Eigen::Matrix<float, 4, 1>; PointT = pcl::PointXYZ][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:907:10:[m[K   required from â€˜[01m[Kstd::size_t pcl::computeCentroid(const pcl::PointCloud<PointT>&, PointOutT&) [with PointInT = pcl::PointXYZ; PointOutT = Eigen::Matrix<float, 4, 1>; std::size_t = long unsigned int][m[Kâ€™
[01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:133:23:[m[K   required from here
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp:23:8:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kvalue[m[Kâ€™ is not a member of â€˜[01m[Kboost::mpl::aux::nested_type_wknd<boost::mpl::apply<pcl::traits::has_xyz<mpl_::arg<1> >, Eigen::Matrix<float, 4, 1>, mpl_::na, mpl_::na, mpl_::na, mpl_::na> >[m[Kâ€™
   23 | struct [01;31m[Kand_impl< true,T1,T2,T3,T4 >[m[K
      |        [01;31m[K^~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/include/boost/mpl/aux_/include_preprocessed.hpp:37[m[K,
                 from [01m[K/usr/include/boost/mpl/bind.hpp:50[m[K,
                 from [01m[K/usr/include/boost/mpl/lambda.hpp:18[m[K,
                 from [01m[K/usr/include/boost/mpl/apply.hpp:25[m[K,
                 from [01m[K/usr/include/boost/mpl/aux_/fold_impl.hpp:19[m[K,
                 from [01m[K/usr/include/boost/mpl/fold.hpp:20[m[K,
                 from [01m[K/usr/include/boost/mpl/remove_if.hpp:18[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/for_each_type.h:51[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/conversions.h:51[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/io/file_io.h:40[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/io/pcd_io.h:45[m[K,
                 from [01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:2[m[K:
/usr/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp: In instantiation of â€˜[01m[Kstruct boost::mpl::bind1<pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> >, boost::mpl::bind1<boost::mpl::quote1<boost::fusion::result_of::value_of>, mpl_::arg<1> > >::apply<boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0> >[m[Kâ€™:
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp:36:8:[m[K   required from â€˜[01m[Kstruct boost::mpl::apply_wrap1<boost::mpl::bind1<pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> >, boost::mpl::bind1<boost::mpl::quote1<boost::fusion::result_of::value_of>, mpl_::arg<1> > >, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/apply.hpp:42:8:[m[K   required from â€˜[01m[Kstruct boost::mpl::apply1<boost::mpl::bind1<pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> >, boost::mpl::bind1<boost::mpl::quote1<boost::fusion::result_of::value_of>, mpl_::arg<1> > >, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0> >[m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/query/detail/find_if.hpp:33:35:[m[K   required from â€˜[01m[Kstruct boost::fusion::detail::apply_filter<boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>, boost::mpl::bind1<pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> >, boost::mpl::bind1<boost::mpl::quote1<boost::fusion::result_of::value_of>, mpl_::arg<1> > > >[m[Kâ€™
[01m[K/usr/include/boost/mpl/if.hpp:63:11:[m[K   required from â€˜[01m[Kstruct boost::mpl::if_<boost::fusion::detail::apply_filter<boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>, boost::mpl::bind1<pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> >, boost::mpl::bind1<boost::mpl::quote1<boost::fusion::result_of::value_of>, mpl_::arg<1> > > >, boost::mpl::identity<boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0> >, boost::fusion::result_of::advance_c<boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>, 1> >[m[Kâ€™
[01m[K/usr/include/boost/mpl/eval_if.hpp:37:41:[m[K   required from â€˜[01m[Kstruct boost::mpl::eval_if<boost::fusion::detail::apply_filter<boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>, boost::mpl::bind1<pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> >, boost::mpl::bind1<boost::mpl::quote1<boost::fusion::result_of::value_of>, mpl_::arg<1> > > >, boost::mpl::identity<boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0> >, boost::fusion::result_of::advance_c<boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>, 1> >[m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/query/detail/find_if.hpp:148:51:[m[K   [ skipping 4 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:47:46:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each_dispatch(Sequence&, F&, Tag) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; Tag = boost::fusion::forward_traversal_tag][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:143:34:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each(Sequence&, F&, mpl_::false_) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; mpl_::false_ = mpl_::bool_<false>][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/for_each.hpp:35:25:[m[K   required from â€˜[01m[Kconstexpr typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type boost::fusion::for_each(Sequence&, F) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type = void][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:888:29:[m[K   required from â€˜[01m[Kvoid pcl::CentroidPoint<PointT>::get(PointOutT&) const [with PointOutT = Eigen::Matrix<float, 4, 1>; PointT = pcl::PointXYZ][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:907:10:[m[K   required from â€˜[01m[Kstd::size_t pcl::computeCentroid(const pcl::PointCloud<PointT>&, PointOutT&) [with PointInT = pcl::PointXYZ; PointOutT = Eigen::Matrix<float, 4, 1>; std::size_t = long unsigned int][m[Kâ€™
[01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:133:23:[m[K   required from here
[01m[K/usr/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp:144:21:[m[K [01;31m[Kerror: [m[Kno type named â€˜[01m[Ktype[m[Kâ€™ in â€˜[01m[Kstruct boost::mpl::apply_wrap1<pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> >, pcl::detail::AccumulatorXYZ>[m[Kâ€™
  144 |             >::type [01;31m[Ktype[m[K;
      |                     [01;31m[K^~~~[m[K
In file included from [01m[K/usr/include/boost/fusion/algorithm/iteration/for_each.hpp:13[m[K,
                 from [01m[K/usr/include/boost/fusion/include/for_each.hpp:11[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/common/impl/accumulators.hpp:45[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/common/centroid.h:955[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/features/normal_3d.h:46[m[K,
                 from [01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:6[m[K:
/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp: In instantiation of â€˜[01m[Kconstexpr void boost::fusion::detail::for_each_dispatch(Sequence&, F&, Tag) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; Tag = boost::fusion::forward_traversal_tag][m[Kâ€™:
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:143:34:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each(Sequence&, F&, mpl_::false_) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; mpl_::false_ = mpl_::bool_<false>][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/for_each.hpp:35:25:[m[K   required from â€˜[01m[Kconstexpr typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type boost::fusion::for_each(Sequence&, F) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type = void][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:888:29:[m[K   required from â€˜[01m[Kvoid pcl::CentroidPoint<PointT>::get(PointOutT&) const [with PointOutT = Eigen::Matrix<float, 4, 1>; PointT = pcl::PointXYZ][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:907:10:[m[K   required from â€˜[01m[Kstd::size_t pcl::computeCentroid(const pcl::PointCloud<PointT>&, PointOutT&) [with PointInT = pcl::PointXYZ; PointOutT = Eigen::Matrix<float, 4, 1>; std::size_t = long unsigned int][m[Kâ€™
[01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:133:23:[m[K   required from here
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:46:32:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[Kfor_each_linear(const type, const type, pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >&, boost::fusion::result_of::equal_to<boost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >, boost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > > >)[m[Kâ€™
   46 |         [01;31m[Kdetail::for_each_linear([m[K
      |         [01;31m[K~~~~~~~~~~~~~~~~~~~~~~~^[m[K
   47 | [01;31m[K                                fusion::begin(seq)[m[K
      |                                 [01;31m[K~~~~~~~~~~~~~~~~~~[m[K
   48 | [01;31m[K                                , fusion::end(seq)[m[K
      |                                 [01;31m[K~~~~~~~~~~~~~~~~~~[m[K
   49 | [01;31m[K                                , f[m[K
      |                                 [01;31m[K~~~[m[K
   50 | [01;31m[K                                , result_of::equal_to<[m[K
      |                                 [01;31m[K~~~~~~~~~~~~~~~~~~~~~~[m[K
   51 | [01;31m[K                                typename result_of::begin<Sequence>::type[m[K
      |                                 [01;31m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
   52 | [01;31m[K                                , typename result_of::end<Sequence>::type>())[m[K;
      |                                 [01;31m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:26:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class First, class Last, class F> constexpr void boost::fusion::detail::for_each_linear(const First&, const Last&, const F&, mpl_::true_)[m[Kâ€™
   26 |     [01;36m[Kfor_each_linear[m[K(First const&, Last const&, F const&, mpl::true_)
      |     [01;36m[K^~~~~~~~~~~~~~~[m[K
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:26:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:50:46:[m[K [01;36m[Knote: [m[K  cannot convert â€˜[01m[Kboost::fusion::result_of::equal_to<boost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >, boost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > > >{boost::fusion::extension::equal_to_impl<boost::fusion::filter_view_iterator_tag>::apply<boost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >, boost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > > >()}[m[Kâ€™ (type â€˜[01m[Kboost::fusion::result_of::equal_to<boost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >, boost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > > >[m[Kâ€™) to type â€˜[01m[Kmpl_::true_[m[Kâ€™ {aka â€˜[01m[Kmpl_::bool_<true>[m[Kâ€™}
   50 |                                 , result_of::[01;36m[Kequal_to<[m[K
      |                                              [01;36m[K^~~~~~~~~[m[K
   51 | [01;36m[K                                typename result_of::begin<Sequence>::type[m[K
      |                                 [01;36m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
   52 | [01;36m[K                                , typename result_of::end<Sequence>::type>()[m[K);
      |                                 [01;36m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:33:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class First, class Last, class F> constexpr void boost::fusion::detail::for_each_linear(const First&, const Last&, F&, mpl_::false_)[m[Kâ€™
   33 |     [01;36m[Kfor_each_linear[m[K(First const& first, Last const& last, F& f, mpl::false_)
      |     [01;36m[K^~~~~~~~~~~~~~~[m[K
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:33:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:50:46:[m[K [01;36m[Knote: [m[K  cannot convert â€˜[01m[Kboost::fusion::result_of::equal_to<boost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >, boost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > > >{boost::fusion::extension::equal_to_impl<boost::fusion::filter_view_iterator_tag>::apply<boost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >, boost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > > >()}[m[Kâ€™ (type â€˜[01m[Kboost::fusion::result_of::equal_to<boost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >, boost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > > >[m[Kâ€™) to type â€˜[01m[Kmpl_::false_[m[Kâ€™ {aka â€˜[01m[Kmpl_::bool_<false>[m[Kâ€™}
   50 |                                 , result_of::[01;36m[Kequal_to<[m[K
      |                                              [01;36m[K^~~~~~~~~[m[K
   51 | [01;36m[K                                typename result_of::begin<Sequence>::type[m[K
      |                                 [01;36m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
   52 | [01;36m[K                                , typename result_of::end<Sequence>::type>()[m[K);
      |                                 [01;36m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/include/boost/fusion/view/filter_view/filter_view.hpp:14[m[K,
                 from [01m[K/usr/include/boost/fusion/algorithm/transformation/filter_if.hpp:11[m[K,
                 from [01m[K/usr/include/boost/fusion/include/filter_if.hpp:11[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/common/impl/accumulators.hpp:47[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/common/centroid.h:955[m[K,
                 from [01m[K/usr/include/pcl-1.12/pcl/features/normal_3d.h:46[m[K,
                 from [01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:6[m[K:
/usr/include/boost/fusion/view/filter_view/filter_view_iterator.hpp: In instantiation of â€˜[01m[Kconstexpr boost::fusion::filter_iterator<Category, First, Last, Pred>::filter_iterator(const First&) [with Category = boost::fusion::forward_traversal_tag; First = boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>; Last = boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>; Pred = pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> >][m[Kâ€™:
[01m[K/usr/include/boost/fusion/view/filter_view/detail/begin_impl.hpp:38:28:[m[K   required from â€˜[01m[Kstatic constexpr boost::fusion::extension::begin_impl<boost::fusion::filter_view_tag>::apply<Sequence>::type boost::fusion::extension::begin_impl<boost::fusion::filter_view_tag>::apply<Sequence>::call(Sequence&) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; boost::fusion::extension::begin_impl<boost::fusion::filter_view_tag>::apply<Sequence>::type = boost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >][m[Kâ€™
[01m[K/usr/include/boost/fusion/sequence/intrinsic/begin.hpp:82:48:[m[K   required from â€˜[01m[Kconstexpr const typename boost::lazy_enable_if<boost::fusion::traits::is_sequence<Sequence>, boost::fusion::result_of::begin<Sequence> >::type boost::fusion::begin(Sequence&) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; typename boost::lazy_enable_if<boost::fusion::traits::is_sequence<Sequence>, boost::fusion::result_of::begin<Sequence> >::type = boost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:47:46:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each_dispatch(Sequence&, F&, Tag) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; Tag = boost::fusion::forward_traversal_tag][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/detail/for_each.hpp:143:34:[m[K   required from â€˜[01m[Kconstexpr void boost::fusion::detail::for_each(Sequence&, F&, mpl_::false_) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; mpl_::false_ = mpl_::bool_<false>][m[Kâ€™
[01m[K/usr/include/boost/fusion/algorithm/iteration/for_each.hpp:35:25:[m[K   required from â€˜[01m[Kconstexpr typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type boost::fusion::for_each(Sequence&, F) [with Sequence = boost::fusion::filter_view<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >; F = pcl::detail::GetPoint<Eigen::Matrix<float, 4, 1> >; typename boost::enable_if<boost::fusion::traits::is_sequence<Sequence> >::type = void][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:888:29:[m[K   required from â€˜[01m[Kvoid pcl::CentroidPoint<PointT>::get(PointOutT&) const [with PointOutT = Eigen::Matrix<float, 4, 1>; PointT = pcl::PointXYZ][m[Kâ€™
[01m[K/usr/include/pcl-1.12/pcl/common/impl/centroid.hpp:907:10:[m[K   required from â€˜[01m[Kstd::size_t pcl::computeCentroid(const pcl::PointCloud<PointT>&, PointOutT&) [with PointInT = pcl::PointXYZ; PointOutT = Eigen::Matrix<float, 4, 1>; std::size_t = long unsigned int][m[Kâ€™
[01m[K/home/justin/vbm_project/src/pcl_sampling/src/pcl_sampling.cpp:133:23:[m[K   required from here
[01m[K/usr/include/boost/fusion/view/filter_view/filter_view_iterator.hpp:60:71:[m[K [01;31m[Kerror: [m[Kusing invalid field â€˜[01m[Kboost::fusion::filter_iterator<Category, First, Last, Pred>::first[m[Kâ€™
   60 |             : first(filter::iter_call(first_converter::call(in_first))[01;31m[K)[m[K {}
      |                                                                       [01;31m[K^[m[K
[01m[K/usr/include/boost/fusion/view/filter_view/filter_view_iterator.hpp:60:38:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kiter_call[m[Kâ€™ is not a member of â€˜[01m[Kboost::fusion::filter_iterator<boost::fusion::forward_traversal_tag, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> > >::filter[m[Kâ€™ {aka â€˜[01m[Kboost::fusion::detail::static_find_if<boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 0>, boost::fusion::vector_iterator<const boost::fusion::vector<pcl::detail::AccumulatorXYZ>, 1>, boost::mpl::bind1<pcl::detail::IsAccumulatorCompatible<pcl::PointXYZ, Eigen::Matrix<float, 4, 1> >, boost::mpl::bind1<boost::mpl::quote1<boost::fusion::result_of::value_of>, mpl_::arg<1> > > >[m[Kâ€™}
   60 |             : first([01;31m[Kfilter::iter_call(first_converter::call(in_first))[m[K) {}
      |                     [01;31m[K~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
gmake[2]: *** [CMakeFiles/pcl_sampling.dir/build.make:76: CMakeFiles/pcl_sampling.dir/src/pcl_sampling.cpp.o] Error 1
gmake[1]: *** [CMakeFiles/Makefile2:137: CMakeFiles/pcl_sampling.dir/all] Error 2
gmake: *** [Makefile:146: all] Error 2
